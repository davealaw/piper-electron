<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Piper TTS GUI</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    label {
      font-weight: bold;
    }
    input, textarea, select {
      width: 100%;
      margin: 10px 0;
      padding: 6px;
      font-size: 1em;
    }
    button {
      padding: 10px 20px;
      font-size: 1em;
      margin-top: 10px;
    }
    #status {
      margin-top: 10px;
      color: #444;
    }
    .inline-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .inline-group input[type="text"] {
      flex-grow: 1;
    }
    #spinner {
      display: none;
      margin-top: 10px;
    }

    .spinner-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-right: 4px;
      border-radius: 50%;
      background-color: #444;
      animation: blink 1s infinite alternate;
    }

    .spinner-dot:nth-child(2) { animation-delay: 0.2s; }
    .spinner-dot:nth-child(3) { animation-delay: 0.4s; }

    #progressContainer.fade-out {
        opacity: 0.3;
        transition: opacity 0.5s ease;
    }

    @keyframes blink {
      0% { opacity: 0.2; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <h2>Piper TTS</h2>

  <audio id="audioPlayer" src="" preload="auto"></audio>

  <div style="margin-top: 10px;">
    <button onclick="choosePiper()">Choose Piper Executable</button>
    <span id="piperPathDisplay"></span>
   </div>

   <div>
    <button onclick="selectModelDirectory()">Choose Model Folder</button>
    <span id="modelDirDisplay"></span>
  </div>
  
  <label for="modelSelect">Choose Voice Model:</label>
  <select id="modelSelect">
    <option disabled selected>Loading models...</option>
  </select>

  <label for="ttsText">Text to Speak:</label>
  <textarea id="ttsText" rows="20" placeholder="Enter text here..."></textarea>

  <label for="outputPath">Output File (optional):</label>
  <div class="inline-group">
    <input id="outputPath" type="text" readonly placeholder="out.wav (default)" />
    <button onclick="chooseOutput()">Browse...</button>
  </div>

  <button id="speakButton" onclick="speakText()">Speak</button>
  <button onclick="resetToDefaults()" style="margin-left: 10px; background-color: #f44; color: white;">Reset to Defaults</button>

  <p id="status"></p>
  
  <div id="progressContainer" style="display: none; margin-top: 10px;">
    <div style="width: 100%; background: #ccc; border-radius: 4px;">
      <div id="progressBar" style="width: 0%; height: 12px; background: #4caf50; border-radius: 4px;"></div>
    </div>
    <p id="progressText" style="margin: 4px 0 0; font-size: 0.9em;">0%</p>
  </div>

  <div id="audioControls" style="display: none; margin-top: 10px;">
    <button onclick="playAudio()">‚ñ∂Ô∏è Play</button>
    <button onclick="pauseAudio()">‚è∏Ô∏è Pause</button>
    <button onclick="resumeAudio()">üîÑ Resume</button>
    <button onclick="stopAudio()">‚èπÔ∏è Stop</button>
  </div>

<script>
  let outputFilePath = null;

  async function selectModelDirectory() {
    const folder = await window.piperAPI.chooseModelDirectory();
    if (folder) {
      document.getElementById('modelDirectory').textContent = folder;
      await populateVoices(); // re-load voice list
    }
  }

  async function loadSettings() {
    const settings = await window.piperAPI.getLastSettings();

    if (settings.lastText) {
      document.getElementById('ttsText').value = settings.lastText;
    }

    if (settings.lastOutput) {
      document.getElementById('outputPath').value = settings.lastOutput;
    }

    document.getElementById('status').textContent = '';
  }

  async function populateVoices() {
    const voices = await window.piperAPI.getVoiceModels();
    const select = document.getElementById('modelSelect');
    select.innerHTML = '';

    if (!voices.length) {
      const opt = document.createElement('option');
      opt.text = 'No models found';
      opt.disabled = true;
      select.appendChild(opt);
      return;
    }

    voices.forEach(model => {
      const opt = document.createElement('option');
      opt.value = model;
      opt.text = model.split('/').pop(); // or format however you like
      select.appendChild(opt);
    });

    // Select previously saved model if still valid
    const last = await window.piperAPI.getLastSettings();
    if (last?.lastModel && voices.includes(last.lastModel)) {
      select.value = last.lastModel;
    }
  }

  /*
  async function populateVoices() {
    const voices = await window.piperAPI.getVoiceModels();
    const select = document.getElementById('modelSelect');
    const settings = await window.piperAPI.getLastSettings();

    select.innerHTML = '';

    if (!voices.length) {
      const opt = document.createElement('option');
      opt.text = 'No models found';
      opt.disabled = true;
      select.appendChild(opt);
      return;
    }

    voices.forEach(model => {
      const opt = document.createElement('option');
      opt.value = model;
      opt.text = model.split('/').pop();
      if (model === settings.lastModel) {
        option.selected = true;
      }      
      select.appendChild(opt);
    });
  }
  */
/*
  async function populateVoices() {
    const models = await window.piperAPI.getVoiceModels();
    const settings = await window.piperAPI.getLastSettings();

    const select = document.getElementById('modelSelect');
    select.innerHTML = '';

    models.forEach(model => {
      const option = document.createElement('option');
      option.value = model;
      option.textContent = model;
      if (model === settings.lastModel) {
        option.selected = true;
      }
      select.appendChild(option);
    });
  }
*/
  async function chooseOutput() {
    const selected = await window.piperAPI.chooseOutputFile();
    if (selected) {
      outputFilePath = selected;
      document.getElementById('outputPath').value = outputFilePath;
    }
  }

  async function choosePiper() {
    const selected = await window.piperAPI.choosePiperPath();
    if (selected) {
      document.getElementById('piperPathDisplay').textContent = selected;
      updateSpeakButtonState();
    }
  }

  async function updateSpeakButtonState() {
    const isValid = await window.piperAPI.validatePiperPath();
    document.getElementById('speakButton').disabled = !isValid;
  }

  async function speakText() {
    const text = document.getElementById('ttsText').value;
    const modelPath = document.getElementById('modelSelect').value;
    const status = document.getElementById('status');
    const speakBtn = document.getElementById('speakButton');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');

    speakBtn.disabled = true;
    status.textContent = 'Processing...';
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    progressText.textContent = '0%';

    // Estimate duration based on text length
    const charsPerSecond = 15; // tweak this if needed
    const estimatedDuration = (text.length / charsPerSecond) * 1000;
    const startTime = Date.now();

    // Progress animation loop
    let progressTimer = setInterval(() => {
      const elapsed = Date.now() - startTime;
      let percent = Math.min(100, Math.floor((elapsed / estimatedDuration) * 100));
      progressBar.style.width = percent + '%';
      progressText.textContent = percent + '% (estimated)';
    }, 100);

    try {      
      await window.piperAPI.speak(text, modelPath, outputFilePath);
      const audio = document.getElementById('audioPlayer');
      audio.src = outputFilePath;
      audio.load();
      audio.play();

      clearInterval(progressTimer);

      status.textContent = 'Playing...';
      document.getElementById('audioControls').style.display = 'block';
    } catch (err) {
      status.textContent = 'Error: ' + err;
    }
    
    speakBtn.disabled = false;
  }
  
  async function resetToDefaults() {
    const confirmed = confirm('Are you sure you want to reset all settings to defaults?');
    if (!confirmed) return;

    await window.piperAPI.resetSettings();
    location.reload(); // reloads the app with default state
  }

  async function cancelSpeak() {
    const canceled = await window.piperAPI.cancelSpeak();
    if (canceled) {
      const status = document.getElementById('status');
      status.textContent = 'Cancelled.';
      document.getElementById('speakButton').disabled = false;
      document.getElementById('cancelButton').disabled = true;
      document.getElementById('progressBar').style.width = '0%';
      document.getElementById('progressPercent').textContent = '';
      document.getElementById('progressContainer').style.display = 'none';
    }
  }

  function playAudio() {
    const audio = document.getElementById('audioPlayer');
    audio.play();
  }

  function pauseAudio() {
    const audio = document.getElementById('audioPlayer');
    audio.pause();
  }

  function resumeAudio() {
    const audio = document.getElementById('audioPlayer');
    audio.play(); // resume is same as play in HTML5
  }

  function stopAudio() {
    const audio = document.getElementById('audioPlayer');
    audio.pause();
    audio.currentTime = 0;
  }

  const audio = document.getElementById('audioPlayer');

  audio.onplay = () => {
    document.getElementById('status').textContent = 'Playing...';
    document.getElementById('audioControls').style.display = 'block';
  };

  audio.onpause = () => {
    document.getElementById('status').textContent = 'Paused';
  };

  audio.onended = () => {
    document.getElementById('status').textContent = 'Done.';
    document.getElementById('audioControls').style.display = 'none';
    progressContainer.style.display = 'none';
    speakBtn.disabled = false;
  };

  audio.ontimeupdate = () => {
    const progress = document.getElementById('progressBar');
    const percent = (audio.currentTime / audio.duration) * 100;
    progress.style.width = `${percent.toFixed(0)}%`;
    progressText.textContent = `${percent.toFixed(0)}%`;
  };

  window.addEventListener('DOMContentLoaded', async () => {
    // Load saved model directory (if any)
    const modelDir = await window.piperAPI.getModelDirectory();
    if (modelDir) {
      document.getElementById('modelDirDisplay').textContent = modelDir;
      await populateVoices();  // <== this is essential
    } else {
      document.getElementById('modelDirDisplay').textContent = 'No directory selected';
    }

    // Load last settings like text/model/output
    const last = await window.piperAPI.getLastSettings();
    if (last?.lastText) {
      document.getElementById('textInput').value = last.lastText;
    }

    if (last?.lastModel) {
      const voiceSelect = document.getElementById('modelSelect');
      const option = Array.from(voiceSelect.options).find(opt => opt.value === last.lastModel);
      if (option) {
        voiceSelect.value = last.lastModel;
      }
    }
  });

  // Call on load
  window.onload = async () => {

    await loadSettings();

    /*
    const dir = await window.piperAPI.getModelDirectory();
    if (dir) {
      document.getElementById('modelDirDisplay').textContent = dir;
    }    
    await populateVoices();
    */

    const path = await window.piperAPI.getPiperPath();
    if (path) {
      document.getElementById('piperPathDisplay').textContent = path;
    }

    updateSpeakButtonState();
  };

</script>

</body>
</html>
